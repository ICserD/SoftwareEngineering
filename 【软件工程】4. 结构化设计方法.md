前言：在冒号前没有加粗的部分笔者认为是理解即可的内容

含有比较重点的：模块内聚

# 结构化设计方法



## 4.1软件设计的概念及原则

模块独立性、提高抽象层次、复用性设计、灵活性设计

**概念**：是一项核心的工程活动

**软件设计的原则**：分而治之；模块独立性；

#### 模块独立性

模块独立性的度量准则：

耦合：是模块之间的互相连接的紧密程度的度量

内聚：是模块功能强度的度量。

##### **模块独立性比较强**的模块应该是**高内聚低耦合**的模块（感觉理解即可）

![image-20240531203707925](https://cdn.jsdelivr.net/gh/NGSJCBF/img@main/img/202406012246168.png)

==非直接耦合==(Nondirect Coupling)：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。非直接耦合的模块独立性最强。

==数据耦合==(Data Coupling)：一个模块访问另一个模块时，彼此之间是通过简单数据参数(不是控制参数、公共数据结构或外部变量) 来交换输入、输出信息的。也是较理想的耦合。

==特征耦合==(Stamp Coupling)：一组模块通过参数表传递记录信息，就是特征耦合。这个记录是某一数据结构的子结构，而不是简单变量。

==控制耦合==(Control Coupling)：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。

==公共耦合==(Common Coupling)：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。

==内容耦合==(Content Coupling):一个模块直接访问另一个模块的内部数据; 一个模块不通过正常入口转到另一模块内部;两个模块有一部分程序代码重迭(只可能出现在汇编语言中);一个模块有多个入口。

##### 设计原则( 即尽量提高==模块独立性==，降低耦合性 )

> **尽量使用数据耦合**
>
> **少用控制耦合**
>
> **限制使用公共耦合（除非传递大量数据）**
>
> **完全不用内容耦合**

##### ==模块内聚==

![image-20240531205408046](https://cdn.jsdelivr.net/gh/NGSJCBF/img@main/img/202406012251759.png)

==偶然内聚==（Coincidental Cohesion）：当模块内各部分之间没有联系，或者即使有联系，这种联系也很松散，则称这种模块为偶然内聚模块，内聚程度最低。

==逻辑内聚==（Logical Cohesion）：把几种相关的功能组合在一起，每次被调用时，由传送给模块的判定参数来确定该模块应执行哪个功能。
缺点：
1）不易修改，因包含多个功能
2）需传递控制参数——控制耦合
3）未用部分调入内存，影响效率

==时间内聚==（Classical Cohesion）：时间内聚模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间段内执行。

==过程内聚==（Procedural Cohesion）：如果一个模块内的处理是相关的**，**而且必须以特定次序执行**，**则是过程内聚。使用流程图做为工具设计程序时，把流程图中的某一部分划出组成模块，就得到过程内聚模块。
 例如，把流程图中的循环部分、判定部分、计算部分分成三个模块，这三个模块都是过程内聚模块。
过程内聚仅包含完整功能的一部分**。**

![image-20240531210635343](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531210635343.png)

==顺序内聚==：一个模块中的处理元素和同一功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。根据数据流图划分模块时，通常得到顺序内聚的模块。

==功能内聚==(Functional Cohesion)：一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。
优点：容易修改和维护

### 提高抽象层次

抽象是指忽视一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。

当我们进行软件设计时，设计开始时应尽量提高软件的抽象层次，按抽象级别从高到低进行软件设计。

### 复用性设计

复用是指同一事物不做修改或稍加修改就可以多次重复使用。将复用的思想用于软件开发，称为软件复用。

我们将软件的重用部分称为软构件。

也就是说，在构造新的软件系统时不必从零做起，可以直接使用已有的软构件即可组装（或加以合理修改）成新的系统。



### 灵活性设计

> 在设计中引入灵活性的方法有：
>
> 降低耦合并提高内聚（易于提高替换能力）；
>
> 建立抽象（创建有多态操作的接口和父类）；
>
> 不要将代码写死（消除代码中的常数）；
>
> 抛出异常（由操作的调用者处理异常）；
>
> 使用并创建可复用的代码。



## 4.2结构化设计

### 4.2.1结构化设计的任务

**软件设计的主要任务**是要解决如何做的问题，要在需求分析的基础上，建立各种设计模型，并通过对设计模型的分析和评估，来确定这些模型是否能够满足需求。
软件设计是将用户需求准确地转化成为最终的软件产品的唯一途径，在需求到构造之间起到了桥梁作用。
在软件设计阶段，往往存在多种设计方案，通常需要在多种设计方案之中进行决策和折中，并使用选定的方案进行后续的开发活动。   

**软件设计的阶段与任务**

从工程管理的角度，可以将软件设计分为概要设计阶段和详细设计阶段。

从技术的角度，传统的结构化方法将软件设计划分为体系结构设计、数据设计、接口设计和过程设计4部分；

面向对象方法则将软件设计划分为体系结构设计、类设计/数据设计、接口设计和构件级设计4部分。

![image-20240531223206669](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531223206669.png)

•软件设计的阶段与任务

体系结构设计**：**体系结构设计定义软件的主要结构元素及其之间的关系**。**

接口设计**：**接口设计描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口**。**

数据设计：传统方法主要根据需求阶段所建立的实体—关系图（ER图）来确定软件涉及的文件系统的结构及数据库的表结构。

过程设计：过程设计的主要工作是确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法。



### 4.2.2结构化设计与结构化分析的关系

•结构化分析的结果为结构化设计提供了最基本的输入信息。两者的关系如图所示。

![image-20240531223127732](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531223127732.png)



### 4.2.3模块结构及表示

一般通过功能划分过程来完成软件结构设计。功能划分过程从需求分析确立的目标系统的模型出发，对整个问题进行分割，使其每一部分用一个或几个软件模块加以解决，整个问题就解决了。

![image-20240531222854309](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222854309.png)

•模块

一个软件系统通常由很多模块组成，结构化程序设计中的函数和子程序都可称为模块，它是程序语句按逻辑关系建立起来的组合体。

模块用矩形框表示，并用模块的名字标记它。

![image-20240531222916038](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222916038.png)

![image-20240531222931857](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222931857.png)

•结构图

结构图（structure chart，SC）是精确表达模块结构的图形表示工具。

(1) 模块的调用关系和接口：在结构图中，两个模块之间用单向箭头连接。

(2) 模块间的信息传递：当一个模块调用另一个模块时，调用模块把数据或控制信息传送给被调用模块，以使被调用模块能够运行。 

(3) 条件调用和循环调用 ：当模块A有条件地调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号；当一个模块A反复地调用模块C和模块D时，在调用箭头尾部则标以一个弧形符号。

(4) 结构图的形态特征。在图中，上级模块调用下级模块，它们之间存在主从关系。



### 4.2.4数据结构及表示

数据结构是数据的各个元素之间逻辑关系的一种表示。

数据结构设计应确定数据的组织、存取方式、相关程度，以及信息的不同处理方法。

数据结构的组织方法和复杂程度可以灵活多样，但典型的数据结构种类是有限的，它们是构成一些更复杂结构的基本构件块。

![image-20240531222823429](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222823429.png)



## 4.3体系结构设计

### 4.3.1基于数据流方法的设计过程

•基于数据流的设计方法也称为过程驱动的设计方法；

•这种方法与软件需求分析阶段的结构化分析方法相衔接，可以很方便地将用数据流图表示的信息转换成程序结构的设计描述；

•这种方法还能和编码阶段的“结构化程序设计方法”相适应，成为常用的结构化设计方法。

![image-20240531221819742](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531221819742.png)





### 4.3.2典型的数据流类型和系统结构

典型的数据流类型有变换型数据流和事务型数据流，数据流的类型不同，得到的系统结构也不同。

通常，一个系统中的所有数据流都可以认为是变换流，但是，当遇到有明显事务特性的数据流时，建议采用事务型映射方法进行设计。

•**变换型数据流**

变换型数据处理问题的工作过程大致分为3步，即取得数据**、**变换数据和给出数据，如图所示。

![image-20240531221953859](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531221953859.png)

•**变换型系统结构图**

变换型系统的结构图由输入、中心变换和输出3部分组成。

![image-20240531222016016](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222016016.png)

•事务型数据流

通常接受一项事务，根据事务处理的特点和性质，选择分派一个适当的处理单元，然后给出结果。

完成选择分派任务的部分称为事务处理中心，或分派部件。

![image-20240531222045222](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222045222.png)

•简化的事务型系统结构图

事务型系统的结构图可以有多种不同的形式，如有多层操作层或没有操作层。

如果调度模块并不复杂，可将其归入事务中心模块。

![image-20240531222059246](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222059246.png)









### 4.3.3变换型映射方法

系统数据处理问题的处理流程总能表示为变换型数据流图，进一步可采用变换型映射方法建立系统的结构图。

也可能遇到明显的事务数据处理问题，这时可采用事务型映射方法**。**

•**变换分析方法的步骤**

(1) 重画数据流图。在需求分析阶段得到的数据流图侧重于描述系统如何加工数据，而重画数据流图的出发点是描述系统中的数据是如何流动的。

(2)在数据流图上区分系统的逻辑输入、逻辑输出和中心变换部分。

(3) 进行一级分解，设计系统模块结构的顶层和第一层。自顶向下设计的关键是找出系统树形结构图的根或顶层模块。

首先设计一个主模块，并用程序的名字为它命名，然后将它画在与中心变换相对应的位置上。

第1层设计：为每个逻辑输入设计一个输入模块，它的功能是为主模块提供数据；为每个逻辑输出设计一个输出模块，它的功能是将主模块提供的数据输出；为中心变换设计一个变换模块，它的功能是将逻辑输入转换成逻辑输出。 

![image-20240531222257259](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222257259.png)

(4) 进行二级分解，设计中、下层模块。

这一步工作是自顶向下，逐层细化，为每一个输入模块、输出模块、变换模块设计它们的从属模块。

设计下层模块的顺序是任意的。但一般是先设计输入模块的下层模块。







### 4.3.4事务型映射方法

![image-20240531222321033](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222321033.png)

•事务分析方法的步骤

(1) 识别事务源。利用数据流图和数据词典，从问题定义和需求分析的结果中，找出各种需要处理的事务。

(2) 规定适当的事务型结构。在确定了该数据流图具有事务型特征之后，根据模块划分理论，建立适当的事务型结构。

(3) 识别各种事务和它们定义的操作**。**

(4) 注意利用公用模块**。**

(5) 建立事务处理模块。对每一事务，或对联系密切的一组事务，建立一个事务处理模块。

(6) 对事务处理模块规定它们全部的下层操作模块**。**

(7) 对操作模块规定它们的全部细节模块**。**

**大型的软件系统通常是变换型结构和事务型结构的混合结构，所以，我们通常利用以变换分析为主，事务分析为辅的方式进行软件结构设计。**

![image-20240531222420422](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222420422.png)



### 4.3.5软件模块结构的改进方法

(1) 模块功能的完善化。

(2) 消除重复功能，改善软件结构**。**

(3) 模块的作用范围应在控制范围之内**。**

(4) 尽可能减少高扇出结构，随着深度增大扇入。 

(5) 避免或减少使用病态连接。

(6) 模块的大小要适中。 

![image-20240531222553214](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222553214.png)



  第2步：确定数据流图具有变换特性还是事务特性。

  通过对精化后的数据流图进行分析，可以看到整个系统是对存款及取款两种不同的事务进行处理，因此具有事务特性。

![image-20240531222617277](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222617277.png)

![image-20240531222624053](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222624053.png)

![image-20240531222631734](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222631734.png)

![image-20240531222638691](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222638691.png)

![image-20240531222646834](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222646834.png)

![image-20240531222654916](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222654916.png)

![image-20240531222702364](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531222702364.png)



## 4.4接口设计

•接口设计概述

接口设计的依据是数据流图中的自动化系统边界。

接口设计主要包括3个方面：模块或软件构件间的接口设计；软件与其他软硬件系统之间的接口设计；软件与人（用户）之间的交互设计。

人机交互（用户）界面是人机交互的主要方式

•人机交互界面

为了设计好人机交互界面，设计者需要了解用户界面应具有的特性；

还应该认真研究使用软件的用户，包括用户是什么人？用户怎样学习与新的计算机系统进行交互？用户需要完成哪些工作？等等。

•用户界面应具备的特性 

可使用性：包括使用简单、界面一致、拥有HELP帮助功能、快速的系统响应和低的系统成本、具有容错能力等。

灵活性：考虑到用户的特点、能力和知识水平，应当使用户接口满足不同用户的要求。

可靠性**：**用户界面的可靠性是指无故障使用的间隔时间。用户界面应能保证用户正确、可靠地使用系统，保证有关程序和数据的安全性**。**

•用户类型 

外行型：以前从未使用过计算机系统的用户。

初学型：尽管对新的系统不熟悉，但对计算机还有一些使用经验的用户。

熟练型：对一个系统有相当多的经验，能够熟练操作的用户。

专家型：这一类用户了解系统内部的构造，有关于系统工作机制的专业知识，具有维护和修改基本系统的能力。专家型需要为他们提供能够修改和扩充系统能力的复杂界面。



在选用界面形式的时候，应当考虑每种类型的优点和限制，可以从以下几个方面来考察：

(1) 使用的难易程度：对于没有经验的用户，该界面使用的难度有多大。

(2) 学习的难易程度**：**学习该界面的命令和功能的难度有多大**。**

(3) 操作速度：在完成一个指定操作时，该界面在操作步骤、击键和反应时间等方面效率有多高。

(4) 复杂程度：该界面提供了什么功能、能否用新的方式组合这些功能以增强界面的功能。

(5) 控制**：**人机交互时**，**是由计算机还是由人发起和控制对话**。**

(6) 开发的难易程度：该界面设计是否有难度、开发工作量有多大。

人机交互的设计有若干准则，包括以下内容：

(1) 一致性。采用一致的术语、一致的步骤和一致的活动。

(2) 操作步骤少。使击键或点击鼠标的次数减到最少，甚至要减少做某些事所需的下拉菜单的距离。

(3) 不要“哑播放”**。**

(4) 提供Undo功能**。**

(5) 减少人脑的记忆负担。不应该要求人从一个窗口中记住某些信息，然后在另一个窗口中使用。

(6) 提高学习效率。为高级特性提供联机帮助，以便用户在需要时容易找到。



## 4.5 数据设计

#### 文件设计 

以下几种情况适合于选择文件存储。

(1) ==数据量较大==的非结构化数据，如多媒体信息。

(2) ==数据量大，信息松散==，如历史记录、档案文件等。

(3) ==非关系层次化数据==，如系统配置文件。

(4) ==对数据的存取速度要求极高的情况。==

(5) ==临时存放的数据。==

一般要根据文件的特性，来确定文件的组织方式。

(1) ==顺序文件==：这类文件分两种，一种是连续文件，另一种是串联文件。  

(2) ==直接存取文件==：可根据记录关键字的值，通过计算直接得到记录的存放地址。

(3) ==索引顺序文件==：其基本数据记录按顺序文件组织，记录排列顺序必须按关键字值升序或降序安排，且具有索引部分，索引部分也按同一关键字进行索引。 

(4) ==分区文件==：这类文件主要用于存放程序。它由若干称为成员的顺序组织的记录组和索引组成。

  每一个成员就是一个程序，由于各个程序的长度不同，所以各个成员的大小也不同，需要利用索引给出各个成员的程序名、开始存放位置和长度。 

(5) ==虚拟存储文件==：这是基于操作系统的请求页式存储管理功能而建立的索引顺序文件。 

#### 数据库设计 

根据数据库的组织，可以将数据库分为网状数据库、层次数据库、关系数据库、面向对象数据库、文档数据库、多维数据库等。

关系数据库最成熟，应用也最广泛，一般情况下，大多数设计者都会选择关系数据库。

在结构化设计方法中，很容易将结构化分析阶段建立的实体—关系模型映射到关系数据库中。  

##### 数据对象实体的映射

一个数据对象（实体）可以映射为一个表或多个表，当分解为多个表时，可以采用横切和竖切的方法。

竖切常用于实例较少而属性很多的对象**。**通常将经常使用的属性放在主表中，而将其他一些次要的属性放到其他表中。

横切常常用于记录与时间相关的对象**。**往往在主表中只记录最近的对象**，**而将以前的记录转到对应的历史表中**。**

##### 关系的映射

一对一关系的映射**：**可以在两个表中都引入外键，进行双向导航。也可以将两个数据对象组合成一张单独的表。

一对多关系的映射：可以将关联中的“一”端毫无变化地映射到一张表，将关联中表示“多”的端上的数据对象映射到带有外键的另一张表，使外键满足关系引用的完整性。

多对多关系的映射：为了表示多对多关系，关系模型必须引入一个关联表，将两个数据实体之间的多对多关系转换成两个一对多关系。





## 4.6过程设计

概要设计的任务完成后，就进入详细设计阶段，也就是过程设计阶段。

> 表达过程规格说明的工具称为过程描述工具，可以将过程描述工具分为以下3类。
>
> (1)==图形工具==：把过程的细节用图形方式描述出来，如程序流程图、N-S图、PAD图、决策树等。
>
> (2) ==表格工具==：用一张表来表达过程的细节。这张表列出了各种可能的操作及其相应的条件，即描述了输入、处理和输出信息，如决策表。
>
> (3) ==语言工具==：用某种类高级语言（称为伪代码）来描述过程的细节，如很多数据结构教材中使用类Pascal、类C语言来描述算法。

**为了克服软件危机，引发了程序设计的一场革命，诞生了结构化程序设计方法**。

#### 结构化程序设计的概念与原则

最早由E. W. Dijkstra提出;建议从高级语言中取消GOTO语句；

1966年，Bohm和Jacopini证明：只用三种基本的控制结构“顺序”、“选择”和“循环”就能实现任何单入口和单出口的没有“死循环”的程序。

#### 结构程序设计的概念

如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。

#### 结构程序设计的主要原则

> (1)使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑。
> (2)选用的控制结构只准许有一个入口和一个出口。
> (3)程序语句组成容易识别的块（Block），每块只有一个入口和一个出口。
> (4)复杂结构应该用基本控制结构进行组合嵌套来实现。
> (5)语言中没有的控制结构，可用一段等价的程序段模拟， 但要求该程序段在整个系统中应前后一致。
> (6) 严格控制GOTO语句，仅在下列情形才可使用：
> 用非结构化的程序设计语言去实现结构化的构造。
> 若不使用GOTO语句就会使程序功能模糊。
> 在某种可以改善而不是损害程序可读性的情况下。例如，在查找结束时，文件访问结束时，出现错误情况要从循环中转出时，使用布尔变量和条件结构来实现就不如用GOTO语句来得简洁易懂。
> (7) 在程序设计过程中，尽量采用自顶向下(Top－Down)、逐步细化(Stepwise Refinement)的原则，由粗到细，一步步展开。

#### 程序流程图

程序流程图也称为程序框图，是软件开发者最熟悉的算法表达工具。
早期的流程图也存在一些缺点。特别是表示程序控制流程的箭头，使用的灵活性极大，程序员可以不受任何约束，随意转移控制，这将不符合结构化程序设计的思想。
为使用流程图描述结构化程序，必须对流程图加以限制。

程序流程图的基本控制结构

(1) ==顺序型==：几个连续的加工步骤依次排列构成。

(2) ==选择型==：由某个逻辑判断式的取值决定选择两个加工中的一个。

(3) ==先判定（while）型循环==：在循环控制条件成立时，重复执行特定的加工。

(4) ==后判定（until）型循环==：重复执行某些特定的加工**，**直至控制条件成立**。**

(5) ==多情况（case）型选择==：列举多种加工情况，根据控制变量的取值，选择执行其一。

![image-20240531220249596](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220249596.png)

![image-20240531220259889](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220259889.png)

![image-20240531220307622](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220307622.png)

![image-20240531220314141](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220314141.png)

![image-20240531220320028](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220320028.png)

![image-20240531220328822](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220328822.png)

#### N-S图

Nassi和Shneiderman 提出了一种符合结构化程序设计原则的图形描述工具，叫做盒图 （box-diagram），也叫做N-S图。

在N-S图中，为了表示5种基本控制结构，规定了5种图形构件。

![image-20240531220430648](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220430648.png)

![image-20240531220445062](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220445062.png)

N-S图的特点

(1) 图中每个矩形框（除CASE构造中表示条件取值的矩形框外）都是明确定义了的功能域（即一个特定控制结构的作用域），以图形表示，清晰可见。

(2) 它的控制转移不能任意规定，必须遵守结构化程序设计的要求。

(3) 很容易确定局部数据和（或）全局数据的作用域。

(4) 很容易表现嵌套关系，也可以表示模块的层次结构。

#### PAD图

![image-20240531220529575](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220529575.png)

![image-20240531220536404](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220536404.png)

![image-20240531220541773](C:\Users\29927\AppData\Roaming\Typora\typora-user-images\image-20240531220541773.png)

> •PAD的优点
>
> 使用PAD符号所设计出来的程序必然是结构化程序**。**
>
> PAD图描绘程序结构清晰，图中竖线的总条数就是程序的层次数。
>
> 用PAD图表现程序逻辑易读、易懂、易记。
>
> 容易将PAD图自动转换为高级语言源程序。
>
> PAD图既可以表示程序逻辑，也可用于描绘数据结构。
>
> PAD图的符号支持自顶向下、逐步求精方法的使用。

#### 伪代码

伪代码是一种介于自然语言和形式化语言之间的半形式化语言，是一种用于描述功能模块的算法设计和加工细节的语言，也称为程序设计语言（Program Design Language，PDL）。

伪码的语法规则分为“外语法”和“内语法”。

外语法应当符合一般程序设计语言常用语句的语法规则；

内语法可以用英语中一些简单的句子、短语和通用的数学符号来描述程序应执行的功能。 

**伪代码的基本控制结构**

简单陈述句结构：避免复合语句。

判定结构：IF_THEN_ELSE或CASE_OF结构。

重复结构：WHILE_DO或REPEAT_UNTIL结构。

![image-20240531220805061](https://cdn.jsdelivr.net/gh/NGSJCBF/img@main/img/202406140901497.png)

伪代码的特点

(1) 有固定的关键字外语法，提供全部结构化控制结构、数据说明和模块特征。外语法的关键字是有限的词汇集，它们能对伪代码正文进行结构分割，使之变得易于理解。

(2) 内语法使用自然语言来描述处理特性，为开发者提供方便，提高可读性。

(3) 有数据说明机制，包括简单的（如标量和数组）与复杂的（如链表和层次结构）的数据结构。

(4) 有子程序定义与调用机制，用以表达各种方式的接口说明。

主要包括两个方面：

一是将复杂问题的解法分解和细化成由若干个模块组成的层次结构；

二是将每个模块的功能逐步分解细化为一系列的处理。

在处理较大的复杂任务时，常采取“模块化”的方法，即在程序设计时不是将全部内容都放在同一个模块中，而是分成若干个模块，每个模块实现一个功能。
模块分解完成后，下一步的任务就是将每个模块的功能逐步分解细化为一系列的处理。



**自顶向下、逐步求精的方法的优点** 

(1) 符合人们解决复杂问题的普遍规律。可提高软件开发的成功率和生产率。

(2) 用先全局后局部，先整体后细节，先抽象后具体的逐步求精的过程开发出来的程序具有清晰的层次结构，因此程序容易阅读和理解。

(3) 程序自顶向下、逐步细化，分解成树形结构。 在同一层的结点上做细化工作，相互之间没有关系，因此它们之间的细化工作相互独立。在任何一步发生错误，一般只影响它下层的结点，同一层的其他结点不受影响。

(4) 程序清晰和模块化，使得在修改和重新设计一个软件时，可复用的代码量最大。

(5) 程序的逻辑结构清晰，有利于程序正确性证明。

(6) 每一步工作仅在上层结点的基础上做不多的设计扩展，便于检查。

(7) 有利于设计的分工和组织工作。

