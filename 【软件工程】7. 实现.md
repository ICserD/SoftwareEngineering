# 7 实现
重难点:
- 结构化程序设计的原则和风格
- 软件测试的目的和原则
- 白盒测试、黑盒测试的定义
- **熟练掌握白盒测试中各种逻辑覆盖的基本思想(重点)**
- **熟练掌握黑盒测试中等价划分、边界值分析方法(重点)**
- 软件测试策略中单元测试、组装测试、确认测试和系统测试的相关概念及方法
- 程序调试步骤和几种程序调试方法、过程

## 7.1 编码
### 7.1.1 选择程序设计语言
程序设计语言的分类(很多分类方法).
根据程序设计语言发展的历程，大致分为:
- 第一代语言: 从属于机器的语言
- 第二代语言：汇编语言
- 第三代语言: 高级程序设计语言
- 第四代语言：例：SQL和应用程序生成器
- 第五代语言：自然语言又被称为知识库语言或人工智能语言（LISP或PROLOG）

**如何选择程序设计语言**？
- 系统用户的要求
- 可以使用的编译程序
- 可以得到的软件工具
- 软件规模
- 程序员的知识
- 软件的可移植性要求
- 软件的应用领域(最关键的因素)

### 7.1.2 编码风格
编码风格是指一个人编制程序时所表现出来的特点、习惯、逻辑思路等。

良好编码风格包括：
- 程序内部应该有很好的文档：如标识符、注释良好，程序文档结构易读易理解。
- 数据说明应易于理解和维护
- 语句结构尽可能简单直观
- 输入输出风格遵守人机界面设计准则
- 效率满足用户需求即可

**高质量代码的常规要求**:
- 质量要求:
  - 通过单元测试
- 性能要求
  - 算法效率(Efficiency)。---时间复杂度
  - 性能(效能)(Performance)分析

**高质量代码的其他要求**:
- 代码可读性强:
  - 不要编写大段代码。
    - 对比较复杂的功能，应分解为相对独立的方法(函数)-----功能单一性
    - 不断进行代码重构。提供代码复用性，做到高内聚，低耦合。  一个包不应有太多类，一个类不应有太多函数，一个函数不应有太多代码
  - 命名和注释。遵守编码规范
    - 命名: 做到见文知义
    - 必需的注释:
        1. 类和函数的功能说明
        2. 函数的参数和返回值
        3. 函数中分支
        4. 函数中实现功能的部分
- 可维护性好:
  - 代码不能写死。例:相对路径和绝对路径
  - 预测可能发生的变化。例: 可以将一些关键参数放到配置文件中来应对
- 可变更性好---更多的对设计的要求
  - 利用代码复用提高可变更性
  - 利用设计模式提高可变更性

### 7.1.3 如何做一个合格程序猿
- 项目/任务有多大
  - 代码行、功能点
  - 复杂度如何
- 花了多少时间
- 质量如何
  - 交付(交付给测试人员、交付给顾客)代码的缺陷率（缺陷/项目(任务)规模）、返工工作量
- 是否按时交付
  - 按时交付是建立信任、衡量能力的基础

## 7.2 软件测试的基础
**什么是软件测试？**
是为了发现错误而执行程序的过程。

**软件测试的对象**：整个软件定义、开发周期的产品.

**测试用例**：通常指测试数据和预期的输出结果.

软件缺陷(Bug): 
- 从产品内部看，缺陷是软件产品开发或维护过程中存在的错误、毛病等各种问题.
- 从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背.

软件BUG的分类: 未细化, 可参考 https://www.51cto.com/article/455507.html

软件Bug的属性:
1. 缺陷标识(Identifier)
2. 缺陷类型 (Type)：
3. 缺陷严重程度 (Severity) ：缺陷严重程度是指因缺陷引起的故障对软件产品的影响程度。
4. 缺陷优先级(Priority)： 缺陷的优先级指缺陷必须被修复的紧急程度。
5. 缺陷状态(Status) ：缺陷状态指缺陷通过一个跟踪修复过程的进展情况。
6. 缺陷起源(Origin) ：缺陷来源指缺陷引起的故障或事件第一次被检测到的阶段。
7. 缺陷来源(Source)： 缺陷来源指引起缺陷的起因。
8. 缺陷根源(Root Cause)： 缺陷根源指发生错误的根本因素

### 7.2.1 软件测试的目标
**软件测试存在的矛盾。**
用户希望通过软件测试暴露软件中隐藏的错误和缺陷，以考虑是否可接受该产品。
软件开发者希望通过软件测试表明软件产品中不存在错误，已正确地实现了用户的要求。

**G.Myers给出的软件测试的目的**
- 测试是为了发现错误而执行程序的过程
- 好的测试用例是至今为止尚未发现的错误的测试方案；
- 成功的测试是发现了至今未发现的错误的测试

总之，测试的目的是以最少的时间和人力，系统地找出软件中潜在的各种错误和缺陷；测试附带的收获是它能证明软件的功能和性能与需求说明相符合。

注意：测试不能表明软件中不存在错误，它只能说明软件中存在错误。

### 7.2.2 软件测试的准则
1. 所有测试都能追溯到用户需求 
2. 应该远在测试开始之前就制定出测试计划 
3. 应该把 Pareto原理应用到软件测试中. 
Pareto原理: 80 ％的错误可能是由 20 ％的模块造成的
4. 从“小规模”测试开始，逐步过渡到“大规模”测试 
5. 穷举测试是不可能的
6. 应由独立的第三方从事测试工作

### 7.2.3 软件测试方法
软件测试方法一般分为：静态测试和动态测试。
**静态测试**是指被测程序不在机器上运行，采用人工检测和计算机辅助静态分析的手段对程序进行检测。
**动态测试**是指通过运行程序发现错误，又分黑盒法和白盒法两种。

对于两种动态测试:
- 已知产品应该具有的功能，可以通过黑盒测试来检验每个功能是否符合设计要求。
- 已知产品的内部工作过程，可以通过白盒法来检验每种内部操作是否按要求的规定正常进行。

### 7.2.4 测试步骤
测试的 4 个步骤：
- **单元（模块）测试**: 检查各各程序模块是否有错误，能发现编码和详细设计的错误。
- **集成测试（子系统和系统测试）**: 测试模块（子系统）接口，发现软件设计和需求说明的错误。
- **确认（验收）测试**: 检查软件是否满足用户的需要以及文档资料是否完整、准确
- **平行运行**: 同时运行新、旧系统

![测试步骤](/images/测试步骤.png)

测试与软件开发各阶段的关系:
软件开发过程是一个自顶向下，逐步细化的过程。
软件测试则是依相反顺序自底向上，逐步集成的过程。
![测试与开发各阶段关系](/images/测试与开发各阶段关系.png)

### 7.2.5 测试阶段的信息流
![测试信息流](/images/测试信息流.png)
测试过程需要二类输入:
- 软件配置：软件需求规格说明、软件设计规格说明、源代码等；
- 测试配置：测试计划、测试用例、测试程序等

## 7.3 单元测试
又称模块测试，需要从程序的内部结构出发设计测试用例。

测试目的：发现模块内部可能存在的差错
测试依据：详细设计说明书和源程序清单
测试方法：白盒测试为主，黑盒测试为辅，多个模块并行进行。

### 7.3.1 测试重点
![测试重点](/images/测试重点.png)

#### 模块接口测试
在单元测试的开始，应对通过被测模块的数据流进行测试。

测试项目: 
- 调用本模块的输入参数是否正确；
- 本模块调用子模块时，输入给子模块的参数是否正确；
- 输出给标准函数的参数是否正确；
- 全局量的定义和用法在各摸块中是否一致；
- 与外部设备的输入输出是否正确。

#### 局部数据测试
测试项目:
- 不正确或不一致的数据类型说明
- 使用尚未赋值或尚未初始化的变量
- 错误的初始值或错误的缺省值
- 变量名拼写错或书写错
- 不一致的数据类型
- 全局数据对模块的影响

#### 重要的执行通路测试
测试用例要适当, 关键.

#### 错误处理测试
着重测试以下可能发生的错误：
- 出错的描述是否难以理解
- 出错的描述是否能够对错误定位
- 显示的错误与实际的错误是否相符
- 对错误条件的处理正确与否
- 在对错误进行处理之前，错误条件是否已经引起系统的干预等

#### 边界测试
重点检查刚好等于、大于或小于边界值的数据;
对运行时间有要求的模块，还要专门进行关键路径测试，以确定最坏情况下和平均意义下影响模块运行时间的因素。

### 7.3.2 代码审查
人工测试源程序。
- 参与者：程序的设计者、编写者、测试者没有直接参与系统开发，但有力的程序员。
- 方法：研究设计说明书，一起审查程序代码如何实现设计，从中发现问题。
- 注意：通常代码审查和机器测试结合使用。

### 7.3.3 计算机测试
单元测试通常在编码阶段进行。常用机器测试，即通过运行模块发现问题。

#### 两个重要概念:
- **驱动程序(driver)**：相当于被测试模块的“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出相关结果。
- **存根程序(stub)**：代替被测试模块所调用的模块。不需要具有子模块所有功能，但不允许什么事情也不做。

#### 测试过程中用到的模型元素
![测试用模型元素](/images/测试用模型元素.png)
执行测试存根和驱动程序
- 测试驱动程序模拟了系统中调用被测组件的部分
- 测试存根模拟被测试组件调用的组件

![执行驱动和存根](/images/执行驱动和存根.png)

#### 单元测试的测试环境
![单元测试环境](/images/单元测试环境.png)

例子: 针对下列正文加工系统功能结构图，
若要测试“编辑子系统”，需要上层“驱动模块”和下层“存根程序”:
![测试环境例子](/images/测试环境例子.png)

### 7.3.4 单元测试工具
- JUnit
- Parasoft Jtest
- Parasoft C++Test
- Parasoft Insure++
- Parasoft CodeWizard
- DevPartner Studio Professional 

## 7.4 集成测试
在单元测试之后，将模块组装成系统，为发现并排除模块在连接中可能出现的问题，而进行的测试。

需要考虑:
- 模块连接时穿越模块接口的数据是否会丢失；
- 一个模块对另一个模块是否会产生不利的影响；
- 各子功能组合起来，能否达到预期要求的父功能
- 全局数据结构是否有问题；
- 单个模块的误差累积起来，是否会放大至不能接受的程度。

### 集成测试的两种方式
1. 非渐增式组装方式（Big bang 集成）
对每个模块分别进行单元测试，再把所有模块组装成一个完整的系统进行的测试，从而得到要求的软件系统。 
2. 渐增式组装方式
先对模块进行单元测试，然后将测试后的模块逐步组装成较大的系统；在组装的过程中边连接边测试，以发现连接过程中产生的问题；
渐增式组装方式的三种类型：
    1. 自顶向下的渐增方式
    2. 自底向上结合的渐增方式
    3. 混合渐增测试

例子: 三层调用层次结构(记一下, 下面会多次用到这个例子)
![集成测试例子](/images/集成测试例子.png)

#### 非渐增式:
![非渐增例子](/images/非渐增例子.png)

#### 自顶向下的渐增方式
将模块按系统程序结构，沿控制层次自顶向下进行组装。
不需要驱动模块, 需要存根模块
- 深度优先
![深度优先组装](/images/深度优先组装.png)
- 广度优先
![广度优先组装](/images/广度优先组装.png)

组装步骤:
1. 对主模块进行测试，用存根模块代替下层模块；
2. 根据选定的结合策略，每次用一个实际模块代替一个存根模块；
3. 在结合进一个模块的同时进行测试；
4. 为保证加入的模块没有引进新的错误，可能需要进行回归测试

优点:
- 可以根据系统的功能（功能需求）定义测试用例
- 能在早期验证主要的控制和判断点。
- 选用按深度方向组装的方式，可以首先实现和验证一个完整的软件功能。

缺点:
- 可能遇到逻辑次序上的问题
- 编写存根可能很困难：存根必须允许测试所有可能的条件。
- 可能需要非常多的存根，特别是当系统的最低级别包含许多方法时。

#### 自底向上的渐增方式
从程序模块结构最底层的模块开始组装和测试。
不再需要存根程序，需要驱动模块。

组合策略:
- 把低层模块组合成实现某个特定的软件子功能的族；
- 用驱动程序协调测试数据的输入和输出;
- 对由模块组成的子功能族进行测试;
- 去掉驱动程序，每软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。

例子:
![自底向上组装例子](/images/自底向上组装例子.png)

对功能分解系统不利：
- 最后测试最重要的子系统（UI）

用于集成以下系统:
- 面向对象系统
- 实时系统
- 具有严格性能要求的系统

#### 回归测试
思考：采用“渐增式测试”时，测试中当新的模块结合进来之后，是否需要对程序进行再次测试？

定义：指集成测试中，重新执行已经做过测试的某个子集，以保证上述这些变化没有带来非预期的副作用。

先采取自顶向下的方式测试被修改的模块及其子模块；
然后将这一部分视为子系统，再自底向上测试。

#### 混合策略
1. 衍变的自顶向下的增殖测试
先对输入／输出模块和引入新算法模块进行测试；
再自底向上组装成为功能相当完整且相对独立的子系统；
2. 自底向上一自顶向下的增殖测试
先对含读操作的子系统自底向上直至根结点模块进行组装和测试；
再对含写操作的子系统做自顶向下的组装与测试。

## 7.5 系统测试
- 功能测试
- 结构测试
- 性能测试
- 验收测试
- 安装测试

需求对系统测试的影响：
- 需求越明确，测试就越容易。
- 用例的质量决定了功能测试的容易程度
- 子系统分解的质量决定了结构测试的容易程度
- 非功能需求和约束的质量决定了性能测试的容易程度

![测试团队](/images/测试团队.png)

### 7.5.1 确认测试（验收测试）
又称有效性测试。验证软件的功能、性能及其它特性是否与用户的要求一致。
- 确认测试的基础 ：软件需求规格说明书
- 确认测试的主要工作：有效性测试与软件配置审查
- 主要参与人员：以用户为主
- 确认测试应交付的文档：
  - 确认测试分析报告
  - 最终的用户手册和操作手册
  - 项目开发总结报告。

确认测试的步骤:
![确认测试步骤](/images/确认测试步骤.png)

#### 7.5.1.1 确认测试范围
通常采用黑盒测试，验证被测软件是否满足用户需求。
- 测试计划：包括测试种类及进度安排；
- 测试步骤：描述具体的测试用例
- 测试目的：
  - 确定软件的特性是否与需求相符；
  - 所有的文档都是正确且便于使用；
  - 其它软件需求。
- 测试结果：
  - 与预期的结果相符；
  - 与预期的结果不符：要提交一份问题报告。

#### 7.5.1.2 软件配置复查
目的:
- 保证软件配置的所有成分都齐全；
- 各方面的质量都符合要求；
- 具有维护阶段所必需的细节；
- 而且已经编排好分类的目录。

应当严格遵守用户手册和操作手册中规定的使用步骤，以便检查这些文档资料的完整性和正确性。

#### 7.5.1.3 α测试和β多测试
适用：为多个用户开发的软件 
**α测试**：由用户在开发环境下进行的测试。
主要评价软件产品的:FLURPS(即功能、局域化、可使用性、可靠性、性能和支持）

**β测试**：由最终用户在实际使用环境下进行的测试，这些用户定期返回有关错误信息给开发者。

注意：只有当α测试达到一定的可靠程度时，才开始 β 测试。

### 7.5.2 结构测试与功能测试
结构测试:
- 基本上与白盒测试相同。（参见7.6节白盒测试）
- 目标：覆盖系统设计中的所有路径
- 测试每个组件的所有输入和输出参数。
- 测试所有组件和所有调用（每个组件至少调用一次，每个组件由所有可能的调用方调用）
- 使用条件和迭代测试作为单元测试。

功能测试:
- 基本上与黑盒测试相同。（参见7.7节黑盒测试）
- 目标：测试系统功能测试用例根据需求分析文档（更好：用户手册）设计，并以需求和关键功能（用例）为中心
- 系统被视为黑盒。
- 单元测试用例可以重用，但在面向最终用户的情况下，也必须开发新的测试用例。

### 7.5.3 性能测试
![性能测试](/images/性能测试.png)

### 测试过程总结
测试有自己的生命周期
- 确定测试目标
- 设计测试用例
- 编写测试用例
- 测试测试用例
- 执行测试
- 评估测试结果
- 修改系统
- 执行回归测试

## 7.6 白盒测试技术
白盒测试执行的要求：
- 对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；
- 对程序模块的所有独立的执行路径至少测试一次 
- 在循环的边界和运行界限内执行循环体；
- 测试内部数据结构的有效性。

### 7.6.1 逻辑覆盖
逻辑覆盖是以程序内部的逻辑结构为基础设计测试用例的技术。
- 语句覆盖
- 判定覆盖
- 条件覆盖
- 判定一条件覆盖
- 条件组合覆盖
- 路径覆盖

例子: ![白盒测试例子](/images/白盒测试例子.png)
#### 语句覆盖
**使使得程序中每个语句至少都能被执行一次。**

满足语句覆盖的情况：执行路径 ace
用例格式：[输入(A,B,X)，输出(X)]
选择用例：[(2,0,4),(3)]   1、5

分析:
语句覆盖可以保证程序中的每条语句都得到执行，但发现不了判定中逻辑运算的错误。
例如在第一个判定中把“&&”错误的写成了“||”，这时仍使用该测试用例，则程序仍按照原路径ace执行, 将检测不到此错误。

语句覆盖是最弱的逻辑覆盖标准。 
![语句覆盖例子图](/images/语句覆盖例子图.png)

#### 判定覆盖
**使得程序中每个判定至少为 TRUE 和 FALSE 各一次。**

覆盖情况：应执行路径
[(2,0,4),(3)] ace	TT   1、5
[(1,1,1),(1)] abd	FF   4、8
[(2,1,1),(2)] abe	FT   2、6
[(3,0,3),(1)] acd	TF   1、8

分析:
上述测试用例仍然无法确定判定内部条件的错误。
例如把第二个判定中的条件X>1错误写为X<1，
使用上述测试用例，照样能按原路径执行而不影响结果。
因此，需要有更强的逻辑覆盖标准去检验判定内的条件。
![判定覆盖例子图](/images/判定覆盖例子图.png)

#### 条件覆盖
**使得判定中的每个条件获得各种可能的结果。**

应满足以下覆盖情况：
判定一: A>1, A≤1, B=0, B≠0
判定二: A=2, A≠2, X>1, X≤1

选择用例：
[(2,0,4),(3)] 	ace  1、5
[(1,1,1),(1)] 	abd  4、8

Q: 如果一组测试用例满足条件覆盖，它一定满足判断覆盖吗？
A: 不一定, 比如下例:
[(1,0,3),(4)] 	abe 3、7
[(2,1,1),(2)] 	abe 2、6

![条件覆盖例子图](/images/条件覆盖例子图.png)

#### 判定/条件覆盖
同时满足判断覆盖和条件覆盖。

应满足以下覆盖情况：
A>1, A≤1, B=0, B≠0
A=2, A≠2, X>1, X≤1

应执行路径:
ace ∧ abd 或 acd ∧ abe

选择用例：
[(2,0,4),(3)]	ace	TT   1、5
[(1,1,1),(1)]        abd	FF   4、8

![判定条件覆盖例子图](/images/判定条件覆盖例子图.png)

分析：
从表面上看，判定/条件覆盖测试了各个判定中的所有条件的取值.
但实际上，编译器在检查含有多个条件的逻辑表达式时，某些情况下的某些条件将会被其它条件所掩盖。
因此，判定/条件覆盖也不一定能够完全检查出逻辑表达式中的错误。

#### 条件组合覆盖
**对于每个判定节点而言，其简单判定条件的所有取值组合情况应该覆盖。**

满足以下覆盖情况：
① A>1, B =0    ② A>1, B≠0
③ A≤1, B =0    ④ A≤1, B≠0 
⑤ A=2, X>1     ⑥ A=2,  X≤1 
⑦ A≠2, X>1     ⑧ A≠2, X≤1

选择用例：
[(2,0,4),(3)] ① ⑤ ace
[(2,1,1),(2)] ② ⑥ abe 
[(1,0,3),(4)] ③ ⑦ abe
[(1,1,1),(1)] ④ ⑧ abd

![条件组合覆盖例子图](/images/条件组合覆盖例子图.png)

#### 路径测试
**路径测试就是设计足够的测试用例，覆盖程序中所有可能的路径。**

![路径测试例子图](/images/路径测试例子图.png)

#### 组合覆盖结合路径覆盖
采用任何一种覆盖方法都不能满足要求，所以，在实际的测试用例设计过程中，可以根据需要将不同的覆盖方法组合起来使用，以实现最佳的测试用例设计 。

![组合路径覆盖例子图](/images/组合路径覆盖例子图.png)

#### 总结
![六种覆盖](/images/六种覆盖.png)

### 7.6.2 控制结构测试
1. 基本路径测试
以环形复杂度为基础，导出基本可执行路径集合，然后设计测试用例的方法。
测试用例要保证程序的每个可执行语句至少执行一次。
2. 循环测试
单循环、串接循环、嵌套循环

#### 基本路径测试步骤
1. 根据程序逻辑画出流程图
![基本路径测试步骤1](/images/基本路径测试步骤1.png)
2. 由程序流程图导出程序控制流图
![基本路径测试步骤2](/images/基本路径测试步骤2.png)
3. 计算其环路复杂度
![基本路径测试步骤3](/images/基本路径测试步骤3.png)
4. 确定程序的独立路径
流图中，一条独立路径是至少包含一条在其它独立路径中从未有过的边的路径。
**独立路径条数**是确保程序中，每个可执行语句至少能被执行一次所必需的测试用例数目的上界。
独立路径条数＝程序环路复杂性 V(G)
![基本路径测试步骤4](/images/基本路径测试步骤4.png)

5. 由独立路径导出测试用例
![基本路径测试步骤5](/images/基本路径测试步骤5.png)

#### 循环测试
循环分为4种不同类型：简单循环、嵌套循环、串接循环和非结构循环。
1. 简单测试
按照下列规则设计测试用例：
- 零次循环：跳过循环
- 一次循环：检查循环初始值
- 二次循环：检查多次循环
- m次循环： 检查多次循环
- 最大次数循环n
- 比最大次数多1次(n+1)的循环
- 比最大次数少1次(n-1)的循环
2. 嵌套循环
- 先测试最内层循环：所有外层的循环变量置为最小值，最内层按简单循环测试；
- 由里向外，测试上一层循环：测试时此层以外的所有外层循环的循环变量取最小值，此层以内的所有嵌套内层循环的循环变量取“典型”值，该层按简单循环测试；
- 重复上一条规则，直到所有各层循环测试完毕；
- 对全部各层循环同时取最小循环次数，或者同时取最大循环次数.
3. 串接循环测试:
- 若串接的各个循环相互独立，则可分别采用简单循环的测试方法 
- 若串接的各个循环彼此关联，例如第一个循环执行结果决定第二个循环的初始值，使用嵌套循环的方法进行测试，把第一个循环当作内层循环处理.
4. 不规则循环测试:
- 不规则循环属于非结构化的程序结构；
- 尽量重新设计结构化的程序结构后再进行测试

## 7.7 黑盒测试
黑盒测试主要是为了发现以下**错误**：
- 是否有不正确或遗漏了的功能？
- 能否正确地接受输入？能否正确的输出结果？
- 是否有数据结构错误或外部数据库访问错误？
- 性能上是否能够满足要求？
- 是否有初始化或终止性错误？

**几种黑盒测试技术**：
等价类划分、边界值分析、错误推测法、因果图法

### 7.7.1 等价划分
**基本思想**：
把所有可能的输入数据（包括有效或无效的），划分成若干数据类（等价类），然后从每个数据类中选取少数有代表性的数据做为测试用例。
这种方法完全不考虑程序的内部结构，只依据程序的规格说明来设计测试用例。

**设计测试用例的步骤**:
首先确定每个输入，再为每个输入划分等价类。
1. 划分等价类(列出等价类表)
等价类是指输入数据的子集合。在该子集合中，各输入数据对于发现程序中的错误都是等效的根据程序功能说明，确定有效和无效的等价类。
根据程序功能说明，确定有效和无效的等价类.

2. 根据等价类设计测试用例
包括有效等价类和无效等价类的设计。

#### 步骤1 划分等价类
- **有效等价类**：是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。
- **无效等价类**：是指对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。

在设计测试用例时，要同时考虑有效等价类和无效等价类的设计!!

**等价类划分原则**:
**原则1**：若规定了取值范围，或输入值的个数，则可以确立一个有效等价类和两个无效等价类。

例如程序对输人条件的要求是：输入数是从 1 到 999 .则
![等价类原则1](/images/等价类原则1.png)

**原则2**：如果规定了输入数据的一组值，而且程序要对每种输入数据分别处理，则可为每种输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。

例: 教师上岗方案中规定对教授、副教授、讲师和助教分别计算分数，做相应的处理。因此可以确定4个有效等价类为教授、副教授、讲师和助教，一个无效等价类，它是所有不符合以上身分的人员的输入值的集合。

**原则3**：若规定了输入值的集合，或者是规定了“必须如何”的条件，则可确立一个有效等价类和一个无效等价类。

例： Pascal 语言对变量标识符规定必须“以字母打头”，则所有以字母打头的构成有效等价类，而不以字母打头的归于无效等价类。

**原则4**：如果确知，已划分的等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。

#### 步骤2 确立测试用例
在确立了等价类之后，建立等价类表，列出所有划分出的等价类。
![等价类表](/images/等价类表.png)

1. 为每一个等价类规定一个唯一编号；
2. 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；
3. 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。

例: 
某报表处理系统，要求用户输入处理报表的日期。
系统规定日期由年、月的 6 位数字字符组成，前 4 位代表年，后两位代表月。
设日期限制在 1990 年 1 月至 1999 年 12 月，即系统只能对该段时期内的报表进行处理。如果用户输入的日期不在此范围内，则显示输入错误。
现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。

![例子等价类表](/images/例子等价类表.png)

为有效等价类设计测试用例
![例子有效类用例](/images/例子有效类用例.png)

为每个不合理等价类设计测试用例
![例子无效类用例](/images/例子无效类用例.png)

### 7.7.2 边界值分析
**边界**是指，对于输入和输出等价类而言，稍高和稍低于其边界值的一些特定情况。
经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。
**边界值分析方法思想**：确定边界之后，选取正好等于、刚刚大于或刚刚小于边界的值做为测试数据，而不是选取等价类中典型值或任意值做为测试数据。

通常总是与等价划分技术联合使用，是等价划分方法的补充。
**具体方法**是：先进行等价类划分，然后对每个有效等价类选取边界值。

例：
有两个输入变量x1和x2的程序F，得到的有效等价类是x1 ∈［a，b］和x2 ∈［c，d］。
程序F的输入空间（定义域）如图所示。带阴影矩形中的任何点都是程序F的有效输入。每个输入七个边界取值。
![边界值例子](/images/边界值例子.png)

案例: 佣金问题的边界值测试
某酒水销售公司指派销售员销售各种酒水,其中白酒卖168元/瓶，红酒卖120元/瓶，啤酒卖5元每瓶。对于每个销售员，白酒每月的最高供应量为5000瓶，红酒为3000瓶，啤酒为30000瓶，各销售员每月至少需售出白酒50瓶，红酒30瓶，啤酒300瓶。
奖金计算方法如下:
- 2万元以下（含）：4%
- 2万元（不含）到4.5万（含）：1%
- 4.5万元以上（不含）：0.5%

从输入角度分析该问题。该问题的输入有3个，其对应的等价类划分为：
- 白酒数，有效等价类[50，5000]
- 红酒数，有效等价类[30，3000]
- 啤酒数，有效等价类[300，30000]

按照边界值取值方法，对每个输入分别取7个值。
- 白酒数，{49，50，51，2500，4999，5000，5001}
- 红酒数，{29，30，31，1500，2999，3000，3001}
- 啤酒数，{299，300，301，15000，29999，30000，30001}

根据边界值组合测试用例规则，保留其中一个变量，让其余变量取正常值，共可以得到6*3+1=19个测试用例.
![佣金问题](/images/佣金问题.png)

### 7.7.3 错误推测
**基本思想**：列举程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。
依靠经验和直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例。

## 7.8 调试(Debug)
软件调试是在成功测试之后，进一步诊断和改正程序中潜在的错误。

调试活动的组成部分：
- 确定程序中可疑错误的确切性质和位置。
- 对程序（设计，编码）进行修改，排除这个错误。

调试过程:
1. 从错误的外部表现形式入手，确定程序中出错位置；
2. 研究有关程序，找出错误的内在原因；
3. 修改设计和代码，排除这个错误；
4. 重复进行暴露了这个错误的原始测试或某些有关测试。

![调试活动图](/images/调试活动图.png)

调试在技术上的难度:
- 错误现象与原因所处的位置可能相距甚远。当其它错误得到纠正时，这一错误所表现出的现象可能会暂时消失，但并未实际排除。
- 非错误原因（例如，舍入误差）
- 不容易发现的人为错误。
- 现象是由于难于精确再现的输人状态（例如，实时应用中输入顺序不确定）引起。
- 现象可能是周期出现的。在软、硬件结合的嵌入式系统中常常遇到。

### 7.8.1 调试途径
1. 强行排错(蛮干法)
- 效率最低的方法，常见形式：
- 打印出所有存储内容、代码
- 在程序特定部位设置打印语句
- 自动调试工具。
2. 回溯法（跟踪法）
- 根据错误症状位置，人工沿程序控制流程向回追踪源代码。
- 适用于小程序，路径数目很大时无法进行
3. 归纳法调试
一种从特殊现象推断一般原理的思考方法。
![归纳法调试](/images/归纳法调试.png)
步骤:
- 收集有关数据。列出所有已知的测试用例和程序执行结果。 
- 组织数据。组织整理数据，以发现规律。 3W IH 形式。
- 提出假设。利用分析结果，设计一个或多个关于出错原因的假设。若提不出假设，则需收集更多数据。
- 证明假设。把假设与原始线索或数据进行比较，若它能完全解释一切现象，则假设得到证明；否则，就认为假设不合理、不完全，或是存在多个错误，能消除部分错误
4. 演绎法调试
一种从一般原理或前提出发，经过排除和精化的过程来推导出结论的思考方法。
![演绎法调试](/images/演绎法调试.png)
步骤:
- 列举所有可能出错原因的假设。把所有可能的错误原因列成表。通过它们，组织、分析现有数据。
- 利用已有的测试数据，排除不正确的假设。仔细分析已有的数据，寻找矛盾，力求排除前一步列出的所有原因。如果所有原因都被排除了，则需要补充一些数据（测试用例），以建立新的假设。
- 改进余下的假设。对没有被排除的原因，利用已知的线索，进一步改进，使之更具体化，以便可以精确地确定出错位置。
- 证明余下的假设。见归纳法第四步。

### 7.8.2 调试原则
调试原则:
- 确定错误的性质和位置的原则
- 用头脑去分析思考与错误征兆有关的信息。
- 避开死胡同。
- 只把调试工具当做辅助手段来使用。利用调试工具，可以帮助思考，但不能代替思考。
- 避免用试探法，最多只能把它当做最后手段。

修改错误的原则:
- 修改错误的一个常见失误是只修改了这个错误的征兆或这个错误的表现，而没有修改错误的本身。
- 当心修正一个错误的同时有可能会引入新的错误。
- 修改错误的过程将迫使人们暂时回到程序设计阶段。
- 修改源代码程序，不要改变目标代码。

## 7.9 软件可靠性
### 7.9.1 基本概念
1. 什么是软件可靠性？
程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。
随着运行时间的增加，运行时出现程序故障的概率也将增加，即可靠性随着给定的时间间隔的加大而减少。
2. 什么是软件可用性？
软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。
3. 可靠性和可用性的主要差别：
- 可靠性意味着在 0 到 t 这段时间间隔内系统没有失效；
- 可用性只意味着在时刻 t, 系统是正常运行的.

### 7.9.2 估算平均无故障时间 MTTF
推测错误的产生频度，即推测错误产生的时间间隔。
经验表明，平均无故障时间 MTTF与单位长度程序中剩余的错误数成反比：
![MTTF公式](/images/MTTF公式.png)

### 7.9.3 估算错误的方法
1. 植入错误法
在测试之前由专人在程序中随机地植入一些错误，测试之后，根据测试小组发现的错误中原有的和植入的两种错误的比例，来估计程序中原有错误的总数 ET 。
Mills 将**播种模型**用于程序中残留错误的估算，称**错误植入模型**.
![播种模型](/images/播种模型.png)
2. 分别测试法
Hyman 对错误植入模型的改进.
两个测试员彼此独立测试同一个程序的两个副本,将把其中一个测试员发现的错误作为有标记的错误,由另一名分析员分析他们的测试结果。
![分别测试法](/images/分别测试法.png)

## 小结
- 测试是软件开发最繁重的任务，也是保证软件可靠性最主要的手段。
- 测试的目的是发现程序的错误，而不是证明程序没有错误.
- 设计测试用例和纠错，是搞好软件测试的两项关键技术.
